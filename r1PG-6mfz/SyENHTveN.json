{"_id":"SyENHTveN","title":"BST (does BST has equal keys or not)","body":{"entityMap":{},"blocks":[{"key":"ag6qs","text":"BST (does BST has equal keys or not)","type":"header-one","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"aj43r","text":"Many algorithms will specify that duplicates are excluded. For example, the example algorithms in the MIT Algorithms book usually present examples without duplicates. It is fairly trivial to implement duplicates (either as a list at the node, or in one particular direction.)\n\nMost (that I've seen) specify left children as <= and right children as >. Practically speaking, a BST which allows either of the right or left children to be equal to the root node, will require extra computational steps to finish a search where duplicate nodes are allowed.\n\nIt is best to utilize a list at the node to store duplicates, as inserting an '=' value to one side of a node requires rewriting the tree on that side to place the node as the child, or the node is placed as a grand-child, at some point below, which eliminates some of the search efficiency.\n\nYou have to remember, most of the classroom examples are simplified to portray and deliver the concept. They aren't worth squat in many real-world situations. But the statement, \"every element has a key and no two elements have the same key\", is not violated by the use of a list at the element node.","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"59kd9","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]},"dateCreated":"2018-12-19T13:18:35.609Z","lastUpdated":"2018-12-19T13:19:19.975Z"}
